webpackHotUpdate("contentScript",{

/***/ "./src/content_scripts/uCookie.js":
/*!****************************************!*\
  !*** ./src/content_scripts/uCookie.js ***!
  \****************************************/
/*! exports provided: TCF_VERSION_NUMBER, LOOKING_FOR_LOCATOR_MSG, FOUND_MSG, NOT_FOUND_MSG, GET_TC_DATA_CALL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TCF_VERSION_NUMBER\", function() { return TCF_VERSION_NUMBER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOOKING_FOR_LOCATOR_MSG\", function() { return LOOKING_FOR_LOCATOR_MSG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FOUND_MSG\", function() { return FOUND_MSG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NOT_FOUND_MSG\", function() { return NOT_FOUND_MSG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GET_TC_DATA_CALL\", function() { return GET_TC_DATA_CALL; });\n/* eslint-disable no-underscore-dangle */\n/* global chrome */\n/* global browser */\n\nconst TCF_VERSION_NUMBER = 2;\nconst LOOKING_FOR_LOCATOR_MSG = 'looking for __tcfapiLocator';\nconst FOUND_MSG = 'found';\nconst NOT_FOUND_MSG = 'not found';\nconst GET_TC_DATA_CALL = 'getTCData';\n\nlet api;\n\nif (chrome === undefined) {\n  api = browser;\n} else {\n  api = chrome;\n}\n\n// This line opens up a long-lived connection to your background page.\nconst port = chrome.runtime.connect({ name: 'mycontentscript' });\nport.onMessage.addListener((message, sender) => {\n  console.log('ucookie.js received a message: ', message);\n\n  if (message.greeting === 'hello') {\n    console.log('ucookie.js: ', message);\n  }\n});\n\n// api.tabs.query({ active: true, currentWindow: true }, (tabs) => {\n//   if (tabs[0] === undefined) {\n//     return;\n//   }\n//   const port = api.tabs.connect(tabs[0].id);\n//   port.onMessage.addListener((message, sender) => {\n//     console.log('ucookie.js received a message: ', message);\n\n//     if (message.greeting === 'hello') {\n//       console.log('ucookie.js: ', message);\n//     }\n//   });\n// });\n\nfunction getCmpFrame() {\n  // find the CMP frame\n  let f = window;\n  let cmpFrame;\n  while (!cmpFrame) {\n    try {\n      if (f.frames.__tcfapiLocator) {\n        cmpFrame = f;\n        break;\n      }\n    } catch (ignore) {\n      // ignore so we can keep searching for the __tcfapiLocator frame\n    }\n    if (f === window.top) { break; }\n    f = f.parent;\n  }\n\n  if (!cmpFrame) {\n    return null;\n  }\n  return cmpFrame;\n}\n\nfunction setUpCmpWrapper() {\n  const cmpFrame = getCmpFrame();\n  if (cmpFrame === null) {\n    // The CMP frame was not present\n    return false;\n  }\n\n  const cmpCallbacks = {};\n\n  /* Set up a __cmp function to do the postMessage and\n       stash the callback.\n       This function behaves (from the caller's perspective)\n       identically to the in-frame __cmp call */\n  window.__tcfapiCookieGlasses = (cmd, version, callback, arg) => {\n    const callId = `uCookie_${Math.random()}`;\n    const msg = {\n      __tcfapiCall: {\n        command: cmd,\n        parameter: arg,\n        version,\n        callId,\n      },\n    };\n\n    cmpCallbacks[callId] = callback;\n    cmpFrame.postMessage(msg, '*');\n  };\n\n  // handles incoming messages from CMP\n  function postMessageHandler(event) {\n    /**\n      * when we get the return message, call the mapped callback\n      */\n    let json = {};\n    try {\n      /**\n         * if this isn't valid JSON then this will throw an error\n         */\n      json = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n    } catch (ignore) {\n      // ignore parsing error\n    }\n\n    const payload = json.__tcfapiReturn;\n    if (payload) {\n      // messages we care about will have a payload\n      if (typeof cmpCallbacks[payload.callId] === 'function') {\n        // call the mapped callback and then remove the reference\n        cmpCallbacks[payload.callId](payload.returnValue, payload.success);\n        cmpCallbacks[payload.callId] = null;\n      }\n    }\n  }\n\n  window.addEventListener('message', postMessageHandler, false);\n\n  return true;\n}\n\nconst foundCmpFrame = setUpCmpWrapper();\n\nfunction handleMessage(message) {\n  console.log('ooo received message', message);\n  if (message.message === 'hello') {\n    port.postMessage({ response: 'response from ucookie' });\n  }\n\n  // TODO: reimplement the logic below\n  // sendResponseToPopupJs({ response: 'response!!!' });\n  // // respond to query checking whether there is a __tcfapiLocator iframe\n  // if (request.checkCmpFrame === LOOKING_FOR_LOCATOR_MSG) {\n  //   if (foundCmpFrame) {\n  //     sendResponseToPopupJs({ response: FOUND_MSG });\n  //   } else {\n  //     sendResponseToPopupJs({ response: NOT_FOUND_MSG });\n  //   }\n  //   return true;\n  // } if (request.call === GET_TC_DATA_CALL) {\n  //   // call CMP to get consentData and send it back to popup.js\n  //   window.__tcfapiCookieGlasses(request.call, TCF_VERSION_NUMBER, (tcData, success) => {\n  //     console.log('Cookie Glasses: success', success);\n  //     console.log('Cookie Glasses: response from CMP:', tcData);\n  //     if (request.manual) {\n  //       console.log('Cookie Glasses: success', success);\n  //       console.log('Cookie Glasses: response from CMP:', tcData);\n  //     }\n\n  //     sendResponseToPopupJs({ response: { tcData } });\n  //   });\n  // }\n  return true;\n}\n\n// port.onMessage.addListener(handleMessage);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29udGVudF9zY3JpcHRzL3VDb29raWUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29udGVudF9zY3JpcHRzL3VDb29raWUuanM/YWE2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuLyogZ2xvYmFsIGNocm9tZSAqL1xuLyogZ2xvYmFsIGJyb3dzZXIgKi9cblxuZXhwb3J0IGNvbnN0IFRDRl9WRVJTSU9OX05VTUJFUiA9IDI7XG5leHBvcnQgY29uc3QgTE9PS0lOR19GT1JfTE9DQVRPUl9NU0cgPSAnbG9va2luZyBmb3IgX190Y2ZhcGlMb2NhdG9yJztcbmV4cG9ydCBjb25zdCBGT1VORF9NU0cgPSAnZm91bmQnO1xuZXhwb3J0IGNvbnN0IE5PVF9GT1VORF9NU0cgPSAnbm90IGZvdW5kJztcbmV4cG9ydCBjb25zdCBHRVRfVENfREFUQV9DQUxMID0gJ2dldFRDRGF0YSc7XG5cbmxldCBhcGk7XG5cbmlmIChjaHJvbWUgPT09IHVuZGVmaW5lZCkge1xuICBhcGkgPSBicm93c2VyO1xufSBlbHNlIHtcbiAgYXBpID0gY2hyb21lO1xufVxuXG4vLyBUaGlzIGxpbmUgb3BlbnMgdXAgYSBsb25nLWxpdmVkIGNvbm5lY3Rpb24gdG8geW91ciBiYWNrZ3JvdW5kIHBhZ2UuXG5jb25zdCBwb3J0ID0gY2hyb21lLnJ1bnRpbWUuY29ubmVjdCh7IG5hbWU6ICdteWNvbnRlbnRzY3JpcHQnIH0pO1xucG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2UsIHNlbmRlcikgPT4ge1xuICBjb25zb2xlLmxvZygndWNvb2tpZS5qcyByZWNlaXZlZCBhIG1lc3NhZ2U6ICcsIG1lc3NhZ2UpO1xuXG4gIGlmIChtZXNzYWdlLmdyZWV0aW5nID09PSAnaGVsbG8nKSB7XG4gICAgY29uc29sZS5sb2coJ3Vjb29raWUuanM6ICcsIG1lc3NhZ2UpO1xuICB9XG59KTtcblxuLy8gYXBpLnRhYnMucXVlcnkoeyBhY3RpdmU6IHRydWUsIGN1cnJlbnRXaW5kb3c6IHRydWUgfSwgKHRhYnMpID0+IHtcbi8vICAgaWYgKHRhYnNbMF0gPT09IHVuZGVmaW5lZCkge1xuLy8gICAgIHJldHVybjtcbi8vICAgfVxuLy8gICBjb25zdCBwb3J0ID0gYXBpLnRhYnMuY29ubmVjdCh0YWJzWzBdLmlkKTtcbi8vICAgcG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2UsIHNlbmRlcikgPT4ge1xuLy8gICAgIGNvbnNvbGUubG9nKCd1Y29va2llLmpzIHJlY2VpdmVkIGEgbWVzc2FnZTogJywgbWVzc2FnZSk7XG5cbi8vICAgICBpZiAobWVzc2FnZS5ncmVldGluZyA9PT0gJ2hlbGxvJykge1xuLy8gICAgICAgY29uc29sZS5sb2coJ3Vjb29raWUuanM6ICcsIG1lc3NhZ2UpO1xuLy8gICAgIH1cbi8vICAgfSk7XG4vLyB9KTtcblxuZnVuY3Rpb24gZ2V0Q21wRnJhbWUoKSB7XG4gIC8vIGZpbmQgdGhlIENNUCBmcmFtZVxuICBsZXQgZiA9IHdpbmRvdztcbiAgbGV0IGNtcEZyYW1lO1xuICB3aGlsZSAoIWNtcEZyYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChmLmZyYW1lcy5fX3RjZmFwaUxvY2F0b3IpIHtcbiAgICAgICAgY21wRnJhbWUgPSBmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgIC8vIGlnbm9yZSBzbyB3ZSBjYW4ga2VlcCBzZWFyY2hpbmcgZm9yIHRoZSBfX3RjZmFwaUxvY2F0b3IgZnJhbWVcbiAgICB9XG4gICAgaWYgKGYgPT09IHdpbmRvdy50b3ApIHsgYnJlYWs7IH1cbiAgICBmID0gZi5wYXJlbnQ7XG4gIH1cblxuICBpZiAoIWNtcEZyYW1lKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNtcEZyYW1lO1xufVxuXG5mdW5jdGlvbiBzZXRVcENtcFdyYXBwZXIoKSB7XG4gIGNvbnN0IGNtcEZyYW1lID0gZ2V0Q21wRnJhbWUoKTtcbiAgaWYgKGNtcEZyYW1lID09PSBudWxsKSB7XG4gICAgLy8gVGhlIENNUCBmcmFtZSB3YXMgbm90IHByZXNlbnRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBjbXBDYWxsYmFja3MgPSB7fTtcblxuICAvKiBTZXQgdXAgYSBfX2NtcCBmdW5jdGlvbiB0byBkbyB0aGUgcG9zdE1lc3NhZ2UgYW5kXG4gICAgICAgc3Rhc2ggdGhlIGNhbGxiYWNrLlxuICAgICAgIFRoaXMgZnVuY3Rpb24gYmVoYXZlcyAoZnJvbSB0aGUgY2FsbGVyJ3MgcGVyc3BlY3RpdmUpXG4gICAgICAgaWRlbnRpY2FsbHkgdG8gdGhlIGluLWZyYW1lIF9fY21wIGNhbGwgKi9cbiAgd2luZG93Ll9fdGNmYXBpQ29va2llR2xhc3NlcyA9IChjbWQsIHZlcnNpb24sIGNhbGxiYWNrLCBhcmcpID0+IHtcbiAgICBjb25zdCBjYWxsSWQgPSBgdUNvb2tpZV8ke01hdGgucmFuZG9tKCl9YDtcbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBfX3RjZmFwaUNhbGw6IHtcbiAgICAgICAgY29tbWFuZDogY21kLFxuICAgICAgICBwYXJhbWV0ZXI6IGFyZyxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgY2FsbElkLFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgY21wQ2FsbGJhY2tzW2NhbGxJZF0gPSBjYWxsYmFjaztcbiAgICBjbXBGcmFtZS5wb3N0TWVzc2FnZShtc2csICcqJyk7XG4gIH07XG5cbiAgLy8gaGFuZGxlcyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIENNUFxuICBmdW5jdGlvbiBwb3N0TWVzc2FnZUhhbmRsZXIoZXZlbnQpIHtcbiAgICAvKipcbiAgICAgICogd2hlbiB3ZSBnZXQgdGhlIHJldHVybiBtZXNzYWdlLCBjYWxsIHRoZSBtYXBwZWQgY2FsbGJhY2tcbiAgICAgICovXG4gICAgbGV0IGpzb24gPSB7fTtcbiAgICB0cnkge1xuICAgICAgLyoqXG4gICAgICAgICAqIGlmIHRoaXMgaXNuJ3QgdmFsaWQgSlNPTiB0aGVuIHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgICAgICAgKi9cbiAgICAgIGpzb24gPSB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGV2ZW50LmRhdGEpIDogZXZlbnQuZGF0YTtcbiAgICB9IGNhdGNoIChpZ25vcmUpIHtcbiAgICAgIC8vIGlnbm9yZSBwYXJzaW5nIGVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgcGF5bG9hZCA9IGpzb24uX190Y2ZhcGlSZXR1cm47XG4gICAgaWYgKHBheWxvYWQpIHtcbiAgICAgIC8vIG1lc3NhZ2VzIHdlIGNhcmUgYWJvdXQgd2lsbCBoYXZlIGEgcGF5bG9hZFxuICAgICAgaWYgKHR5cGVvZiBjbXBDYWxsYmFja3NbcGF5bG9hZC5jYWxsSWRdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGNhbGwgdGhlIG1hcHBlZCBjYWxsYmFjayBhbmQgdGhlbiByZW1vdmUgdGhlIHJlZmVyZW5jZVxuICAgICAgICBjbXBDYWxsYmFja3NbcGF5bG9hZC5jYWxsSWRdKHBheWxvYWQucmV0dXJuVmFsdWUsIHBheWxvYWQuc3VjY2Vzcyk7XG4gICAgICAgIGNtcENhbGxiYWNrc1twYXlsb2FkLmNhbGxJZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcG9zdE1lc3NhZ2VIYW5kbGVyLCBmYWxzZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmNvbnN0IGZvdW5kQ21wRnJhbWUgPSBzZXRVcENtcFdyYXBwZXIoKTtcblxuZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKCdvb28gcmVjZWl2ZWQgbWVzc2FnZScsIG1lc3NhZ2UpO1xuICBpZiAobWVzc2FnZS5tZXNzYWdlID09PSAnaGVsbG8nKSB7XG4gICAgcG9ydC5wb3N0TWVzc2FnZSh7IHJlc3BvbnNlOiAncmVzcG9uc2UgZnJvbSB1Y29va2llJyB9KTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlaW1wbGVtZW50IHRoZSBsb2dpYyBiZWxvd1xuICAvLyBzZW5kUmVzcG9uc2VUb1BvcHVwSnMoeyByZXNwb25zZTogJ3Jlc3BvbnNlISEhJyB9KTtcbiAgLy8gLy8gcmVzcG9uZCB0byBxdWVyeSBjaGVja2luZyB3aGV0aGVyIHRoZXJlIGlzIGEgX190Y2ZhcGlMb2NhdG9yIGlmcmFtZVxuICAvLyBpZiAocmVxdWVzdC5jaGVja0NtcEZyYW1lID09PSBMT09LSU5HX0ZPUl9MT0NBVE9SX01TRykge1xuICAvLyAgIGlmIChmb3VuZENtcEZyYW1lKSB7XG4gIC8vICAgICBzZW5kUmVzcG9uc2VUb1BvcHVwSnMoeyByZXNwb25zZTogRk9VTkRfTVNHIH0pO1xuICAvLyAgIH0gZWxzZSB7XG4gIC8vICAgICBzZW5kUmVzcG9uc2VUb1BvcHVwSnMoeyByZXNwb25zZTogTk9UX0ZPVU5EX01TRyB9KTtcbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH0gaWYgKHJlcXVlc3QuY2FsbCA9PT0gR0VUX1RDX0RBVEFfQ0FMTCkge1xuICAvLyAgIC8vIGNhbGwgQ01QIHRvIGdldCBjb25zZW50RGF0YSBhbmQgc2VuZCBpdCBiYWNrIHRvIHBvcHVwLmpzXG4gIC8vICAgd2luZG93Ll9fdGNmYXBpQ29va2llR2xhc3NlcyhyZXF1ZXN0LmNhbGwsIFRDRl9WRVJTSU9OX05VTUJFUiwgKHRjRGF0YSwgc3VjY2VzcykgPT4ge1xuICAvLyAgICAgY29uc29sZS5sb2coJ0Nvb2tpZSBHbGFzc2VzOiBzdWNjZXNzJywgc3VjY2Vzcyk7XG4gIC8vICAgICBjb25zb2xlLmxvZygnQ29va2llIEdsYXNzZXM6IHJlc3BvbnNlIGZyb20gQ01QOicsIHRjRGF0YSk7XG4gIC8vICAgICBpZiAocmVxdWVzdC5tYW51YWwpIHtcbiAgLy8gICAgICAgY29uc29sZS5sb2coJ0Nvb2tpZSBHbGFzc2VzOiBzdWNjZXNzJywgc3VjY2Vzcyk7XG4gIC8vICAgICAgIGNvbnNvbGUubG9nKCdDb29raWUgR2xhc3NlczogcmVzcG9uc2UgZnJvbSBDTVA6JywgdGNEYXRhKTtcbiAgLy8gICAgIH1cblxuICAvLyAgICAgc2VuZFJlc3BvbnNlVG9Qb3B1cEpzKHsgcmVzcG9uc2U6IHsgdGNEYXRhIH0gfSk7XG4gIC8vICAgfSk7XG4gIC8vIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKGhhbmRsZU1lc3NhZ2UpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/content_scripts/uCookie.js\n");

/***/ })

})